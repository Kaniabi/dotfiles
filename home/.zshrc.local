#!/bin/zsh

function genpasswd () {
  PASSWORD_LEVEL=4
  RESULT=""
  for ((i=1;i<=PASSWORD_LEVEL;i++)); do
    PASSWORD_PART="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 4 | tr -d '\n')"
    if [[ $PASSWORD_PART =~ ^[[:upper:]] ]]; then
      PASSWORD_PART="${(U)PASSWORD_PART}"
    else
      PASSWORD_PART="${(L)PASSWORD_PART}"
    fi

    if [[ -n "$RESULT" ]]; then
      RESULT="$RESULT-$PASSWORD_PART"
    else
      RESULT=$PASSWORD_PART
    fi
  done
  echo $RESULT
}

# Aws

function awsin () {
  aws sso login --profile=$1
}

function awsout () {
  aws sso logout --profile=$1
}

# Git

function __git_prompt_git() {
  GIT_OPTIONAL_LOCKS=0 command git "$@"
}   

# Outputs the name of the current branch
# Usage example: git pull origin $(git_current_branch)
# Using '--quiet' with 'symbolic-ref' will not cause a fatal error (128) if
# it's not a symbolic ref, but in a Git repo.
function git_current_branch() {
  local ref
  ref=$(__git_prompt_git symbolic-ref --quiet HEAD 2> /dev/null) 
  local ret=$?
  if [[ $ret != 0 ]]; then
    [[ $ret == 128 ]] && return  # no git repo.
    ref=$(__git_prompt_git rev-parse --short HEAD 2> /dev/null) || return
  fi 
  echo ${ref#refs/heads/}
}   

function gwip() {
  git commit -am "WIP: $*"  && \
  gpush
}

function gshow() {
  git show --name-status "$@"
}

function grev () {
  git commit -am "REV: $*"  && \
  gpush
}

function gsquash () {
  [[ -z "$1" ]] && echo "Usage: gsquash <BRANCH>" && return 9
  local HEAD=$(git rev-parse HEAD)
  git reset --hard $1
  git merge --squash $HEAD
}

function workon () {
  if [[ $1 == "" ]]; then
    pyenv versions
  else
    pyenv shell $1
  fi
}

function grom () {
  git checkout $1 && \
  git rebase ${2:-master} && \
  gpush
}

function gb () {
  git for-each-ref  \
    --sort=committerdate refs/heads/ \
    --format='%(color:yellow)%(align:width=32)%(refname:lstrip=2)%(end)%(color:reset): %(contents:subject) %(color:green)(%(committerdate:relative))%(color:blue) %(authorname)%(color:reset)'
}

function gbst () {
  for i_branch in $( gb ); do printf "$i_branch "; hub ci-status $i_branch; done;
}

function gretag () {
  [[ -z $1 ]] && die "Usage: gretag <TAG>"
  hub tag -d $1
  hub tag $1
  hub push origin --force $1
}

function gpush () {
  hub push --set-upstream origin "$@" $(git_current_branch)
}

function gpull () {
  hub pull
}

# alias gamend='git add -A .;git amend;gpush -f'
# alias gamendn='git add -A .;git commit -an --amend;gpush -f'
function gamend () {
  hub add -A .
  hub commit --amend --no-edit --all
}

function ggrepos () {
  find . -name .git | xargs dirname | grep -v "/\." | sort
}

function ggfetch () {
  REPOS=$(ggrepos)
  parallel gfetch ::: $REPOS
}

function ggpull () {
  REPOS=$(ggrepos)
  for i_repo in ${(f)REPOS}; do
    echo "********************************************************************* $i_repo"
    hub -C $i_repo pull
  done
}

function ggst () {
  REPOS=$(ggrepos)
  for i_repo in ${(f)REPOS}; do
    echo -n "`realpath --relative-to=$PWD $i_repo`  "
    hub -C $i_repo st  # | tail -n +2
  done
}

function gg () {
  REPOS=$(ggrepos)
  for i_repo in ${(f)REPOS}; do
    echo "********************************************************************* $i_repo"
    hub -C $i_repo "$@"
  done
}

function gdiff() {
  git diff --name-status "${@:-master}"
}

# Remote Development

function _redev_aws () {
  aws --profile $REDEV_PROFILE --region=$REDEV_REGION "$@"
}

function redev () {
  REDEV_PROFILE="internal"
  REDEV_REGION="ca-central-1"
  REDEV_INSTANCE_ID="i-0ab78ef84f55fa9b7"
  REDEV_SECURITY_GROUP_ID="sg-0a09dfd46f63d075b"
  REDEV_SECURITY_GROUP_NAME="mi-is-infra_kaniabi"

  CMD=$1
  case $CMD in
    "start")
      INFO "Starting remote development instance..."
      _redev_aws ec2 start-instances --instance-ids=$REDEV_INSTANCE_ID
      INFO "Done."
      ;;
    "stop")
      INFO "*** Stopping remote development instance..."
      _redev_aws ec2 stop-instances --instance-ids=$REDEV_INSTANCE_ID
      INFO "*** Done."
      ;;
    "shell")
      INFO "*** Shell into remote development instance..."
      _redev_aws ssm start-session --target=$REDEV_INSTANCE_ID
      INFO "*** Done."
      ;;
    "ingress")
      INFO "*** List current ingress rules..."
      _redev_aws ec2 describe-security-groups --group-ids=$REDEV_SECURITY_GROUP_ID | jq -r ".SecurityGroups[] | .IpPermissions[] | .IpRanges[] | .CidrIp"
      INFO "*** Done."
      ;;
    "ingress.set")
      CURRENT_IP=$(curl ifconfig.co)
      INFO "*** Add ingress rules for current ip ($CURRENT_IP) ..."
      _redev_aws ec2 authorize-security-group-ingress --group-id $REDEV_SECURITY_GROUP_ID --protocol tcp --port 22 --cidr $CURRENT_IP/32
      INFO "*** Done."
      ;;
    *)
      echo "
redev: Remote Development tool

Commands:
  * start: Starts the instance.
  * stop: Stops the instance.
  * shell: Start a SSM session.
  * ingress: List ingress rules.
  * ingress.set: Add a new ingress rule for the current IP.

PROFILE=$REDEV_PROFILE
REGION=$REDEV_REGION
INSTANCE_ID=$REDEV_INSTANCE_ID"
      _redev_aws ec2 describe-instances --instance-ids=$REDEV_INSTANCE_ID | jq -r '.Reservations[] | .Instances[] | "INSTANCE_IP: \(.PublicIpAddress)\nINSTANCE_STATE: \(.State.Name)"'
      ;;
  esac
}

function tfw () {
  if [[ -z $1 ]]; then
    terraform workspace list
  else
    terraform workspace select "$@"
  fi
}

function _tf_usage () {
  echo "
Usage:
  _tf init
  _tf <CMD> <WORKSPACE> <*PARAMS>
Availabe workspaces:
$(ls -1 './tfvars' | gawk '{ sub(/.tfvars/, "", $1); print("  *", $1) }')
"
  exit 0
}

function _tf_title () {
  COLOR='\033[0;34m'
  RESET='\033[0m'
  echo -e "${COLOR}tf: ************************************************************************ $*${RESET}"
}


function _tf() {
  # Case 1: No tfvars: just run the terraform command.
  if [[ ! -d "tfvars" ]]; then
    _tf_title "Checking tfvars: ./tfvars not found. Running terraform."
    terraform "$@"
    return
  else
    _tf_title "Checking tfvars: ./tfvars directory found. Using tfvars."
  fi

  # Case 2: localbin directory: run the local bin script
  local CMD=$1
  LOCALBIN_CMD="bin/%CMD"
  if [[ -f $LOCALBIN_CMD ]]; then
    _tf_title "Checking localbin: ./bin found. Running $LOCALBIN_CMD"
    return 0
  else
    _tf_title "Checking localbin: ./bin directory not found. Not using localbin."
  fi

  if [[ "$CMD" == "init" ]]; then
    _tf_title "Checking init command: Running terraform init."
    terraform init
    return
  fi

  # Cluster
  local VAR_FILENAME=$2
  shift 2
  local CLUSTER=${VAR_FILENAME%%-*}
  _tf_title "CLUSTER=$CLUSTER"

  # Workspace: we have variations, the new one with `app-env` and the old one
  # with only `env`.
  _tf_title "Checking workspace variation: app-env vs env"
  if terraform workspace list | grep -w "$VAR_FILENAME" >> /dev/null 2>&1; then
    local WORKSPACE=$VAR_FILENAME
    _tf_title "WORKSPACE=$WORKSPACE"
  else
    local WORKSPACE=${VAR_FILENAME#*-}
    _tf_title "WORKSPACE=$WORKSPACE"
  fi

  # Switch workspace if needed.
  local WORKSPACE_CURRENT=$(terraform workspace show)
  if [[ "$WORKSPACE_CURRENT" != "$WORKSPACE" ]]; then
    terraform workspace select "$WORKSPACE"
    WORKSPACE_CURRENT=$(terraform workspace show)
    if [[ "$WORKSPACE_CURRENT" != "$WORKSPACE" ]]; then
      _tf_title "ERROR: Terraform workspaces switch failed. Desired: $WORKSPACE, Current: $WORKSPACE_CURRENT."
      return 9
    fi
  fi

  echo terraform $CMD -var-file "./tfvars/$VAR_FILENAME.tfvars" "$@"
  terraform $CMD -var-file "./tfvars/$VAR_FILENAME.tfvars" "$@"
}

function tfi() {
  _tf init "$@"
}

function tfp() {
  _tf plan "$@"
}

function tfa() {
  _tf apply "$@"
}

function tfd() {
  _tf destroy "$@"
}

function tfpp () {
  local TFPLAN_FILENAME=~/autosync/_work/tfplans/$(basename $PWD)-$(terraform workspace show).tfplan
  terraform -chdir=${1:-.} init
  terraform -chdir=${1:-.} plan -no-color > $TFPLAN_FILENAME
  echo "file://$TFPLAN_FILENAME"
}

function tfshow () {
  terraform show .terraform/tfplan.bin
}

function tfrepos () {
  find -name .terraform | xargs realpath | xargs dirname | grep -v "\."
}

function ttfst () {
  REPOS=$(tfrepos)
  for i_repo in ${(f)REPOS}; do
    echo $i_repo: $(terraform -chdir=$i_repo workspace show)
  done
}

function ttfst () {
  REPOS=$(tfrepos)
  for i_repo in ${(f)REPOS}; do
    echo $i_repo: $(terraform -chdir=$i_repo workspace show)
  done
}

function ttfpp () {
  REPOS=$(tfrepos)
  for i_repo in ${(f)REPOS}; do
    echo "********************************************************************* $(basename $i_repo)"
    tfpp $i_repo
  done
}

function tfapply () {
  if [[ -z $1 ]]; then
    echo "Usage: tfapply <ENVIRONMENT>"
    exit 9
  fi
  if [[ $1 == "prod" ]]; then
    echo "ERROR: You should not use this command for production environment."
    exit 9
  fi
  tfi
  tfw "$1"
  tfa -auto-approve
  # asg.update "$1" 2
  #sleep 150
  #asg.update "$1" 1
}
